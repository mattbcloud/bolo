// Generated by CoffeeScript 1.12.7
(function() {
  var FloodFill, Map, TERRAIN_TYPES, TERRAIN_TYPE_ATTRIBUTES, TILE_SIZE_PIXELS, TILE_SIZE_WORLD, WorldBase, WorldMap, WorldMapCell, WorldPillbox, extendTerrainMap, floor, net, random, ref, ref1, round, sounds,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  round = Math.round, random = Math.random, floor = Math.floor;

  ref = require('./constants'), TILE_SIZE_WORLD = ref.TILE_SIZE_WORLD, TILE_SIZE_PIXELS = ref.TILE_SIZE_PIXELS;

  ref1 = require('./map'), Map = ref1.Map, TERRAIN_TYPES = ref1.TERRAIN_TYPES;

  net = require('./net');

  sounds = require('./sounds');

  WorldPillbox = require('./objects/world_pillbox');

  WorldBase = require('./objects/world_base');

  FloodFill = require('./objects/flood_fill');

  TERRAIN_TYPE_ATTRIBUTES = {
    '|': {
      tankSpeed: 0,
      tankTurn: 0.00,
      manSpeed: 0
    },
    ' ': {
      tankSpeed: 3,
      tankTurn: 0.25,
      manSpeed: 0
    },
    '~': {
      tankSpeed: 3,
      tankTurn: 0.25,
      manSpeed: 4
    },
    '%': {
      tankSpeed: 3,
      tankTurn: 0.25,
      manSpeed: 4
    },
    '=': {
      tankSpeed: 16,
      tankTurn: 1.00,
      manSpeed: 16
    },
    '#': {
      tankSpeed: 6,
      tankTurn: 0.50,
      manSpeed: 8
    },
    ':': {
      tankSpeed: 3,
      tankTurn: 0.25,
      manSpeed: 4
    },
    '.': {
      tankSpeed: 12,
      tankTurn: 1.00,
      manSpeed: 16
    },
    '}': {
      tankSpeed: 0,
      tankTurn: 0.00,
      manSpeed: 0
    },
    'b': {
      tankSpeed: 16,
      tankTurn: 1.00,
      manSpeed: 16
    },
    '^': {
      tankSpeed: 3,
      tankTurn: 0.50,
      manSpeed: 0
    }
  };

  extendTerrainMap = function() {
    var ascii, attributes, key, results, type, value;
    results = [];
    for (ascii in TERRAIN_TYPE_ATTRIBUTES) {
      attributes = TERRAIN_TYPE_ATTRIBUTES[ascii];
      type = TERRAIN_TYPES[ascii];
      results.push((function() {
        var results1;
        results1 = [];
        for (key in attributes) {
          value = attributes[key];
          results1.push(type[key] = value);
        }
        return results1;
      })());
    }
    return results;
  };

  extendTerrainMap();

  WorldMapCell = (function(superClass) {
    extend(WorldMapCell, superClass);

    function WorldMapCell(map, x, y) {
      WorldMapCell.__super__.constructor.apply(this, arguments);
      this.life = 0;
    }

    WorldMapCell.prototype.isObstacle = function() {
      var ref2;
      return ((ref2 = this.pill) != null ? ref2.armour : void 0) > 0 || this.type.tankSpeed === 0;
    };

    WorldMapCell.prototype.hasTankOnBoat = function() {
      var i, len, ref2, tank;
      ref2 = this.map.world.tanks;
      for (i = 0, len = ref2.length; i < len; i++) {
        tank = ref2[i];
        if (tank.armour !== 255 && tank.cell === this) {
          if (tank.onBoat) {
            return true;
          }
        }
      }
      return false;
    };

    WorldMapCell.prototype.getTankSpeed = function(tank) {
      var ref2, ref3;
      if (((ref2 = this.pill) != null ? ref2.armour : void 0) > 0) {
        return 0;
      }
      if ((ref3 = this.base) != null ? ref3.owner : void 0) {
        if (!(this.base.owner.$.isAlly(tank) || this.base.armour <= 9)) {
          return 0;
        }
      }
      if (tank.onBoat && this.isType('^', ' ')) {
        return 16;
      }
      return this.type.tankSpeed;
    };

    WorldMapCell.prototype.getTankTurn = function(tank) {
      var ref2, ref3;
      if (((ref2 = this.pill) != null ? ref2.armour : void 0) > 0) {
        return 0.00;
      }
      if ((ref3 = this.base) != null ? ref3.owner : void 0) {
        if (!(this.base.owner.$.isAlly(tank) || this.base.armour <= 9)) {
          return 0.00;
        }
      }
      if (tank.onBoat && this.isType('^', ' ')) {
        return 1.00;
      }
      return this.type.tankTurn;
    };

    WorldMapCell.prototype.getManSpeed = function(man) {
      var ref2, ref3, tank;
      tank = man.owner.$;
      if (((ref2 = this.pill) != null ? ref2.armour : void 0) > 0) {
        return 0;
      }
      if (((ref3 = this.base) != null ? ref3.owner : void 0) != null) {
        if (!(this.base.owner.$.isAlly(tank) || this.base.armour <= 9)) {
          return 0;
        }
      }
      return this.type.manSpeed;
    };

    WorldMapCell.prototype.getPixelCoordinates = function() {
      return [(this.x + 0.5) * TILE_SIZE_PIXELS, (this.y + 0.5) * TILE_SIZE_PIXELS];
    };

    WorldMapCell.prototype.getWorldCoordinates = function() {
      return [(this.x + 0.5) * TILE_SIZE_WORLD, (this.y + 0.5) * TILE_SIZE_WORLD];
    };

    WorldMapCell.prototype.setType = function(newType, mine, retileRadius) {
      var hadMine, oldLife, oldType, ref2, ref3;
      ref2 = [this.type, this.mine, this.life], oldType = ref2[0], hadMine = ref2[1], oldLife = ref2[2];
      WorldMapCell.__super__.setType.apply(this, arguments);
      this.life = (function() {
        switch (this.type.ascii) {
          case '.':
            return 5;
          case '}':
            return 5;
          case ':':
            return 5;
          case '~':
            return 4;
          default:
            return 0;
        }
      }).call(this);
      return (ref3 = this.map.world) != null ? ref3.mapChanged(this, oldType, hadMine, oldLife) : void 0;
    };

    WorldMapCell.prototype.takeShellHit = function(shell) {
      var neigh, nextType, ref2, ref3, sfx;
      sfx = sounds.SHOT_BUILDING;
      if (this.isType('.', '}', ':', '~')) {
        if (--this.life === 0) {
          nextType = (function() {
            switch (this.type.ascii) {
              case '.':
                return '~';
              case '}':
                return ':';
              case ':':
                return ' ';
              case '~':
                return ' ';
            }
          }).call(this);
          this.setType(nextType);
        } else {
          if ((ref2 = this.map.world) != null) {
            ref2.mapChanged(this, this.type, this.mine);
          }
        }
      } else if (this.isType('#')) {
        this.setType('.');
        sfx = sounds.SHOT_TREE;
      } else if (this.isType('=')) {
        neigh = shell.direction >= 224 || shell.direction < 32 ? this.neigh(1, 0) : shell.direction >= 32 && shell.direction < 96 ? this.neigh(0, -1) : shell.direction >= 96 && shell.direction < 160 ? this.neigh(-1, 0) : this.neigh(0, 1);
        if (neigh.isType(' ', '^')) {
          this.setType(' ');
        }
      } else {
        nextType = (function() {
          switch (this.type.ascii) {
            case '|':
              return '}';
            case 'b':
              return ' ';
          }
        }).call(this);
        this.setType(nextType);
      }
      if (this.isType(' ')) {
        if ((ref3 = this.map.world) != null) {
          ref3.spawn(FloodFill, this);
        }
      }
      return sfx;
    };

    WorldMapCell.prototype.takeExplosionHit = function() {
      var ref2;
      if (this.pill != null) {
        return this.pill.takeExplosionHit();
      }
      if (this.isType('b')) {
        this.setType(' ');
      } else if (!this.isType(' ', '^', 'b')) {
        this.setType('%');
      } else {
        return;
      }
      return (ref2 = this.map.world) != null ? ref2.spawn(FloodFill, this) : void 0;
    };

    return WorldMapCell;

  })(Map.prototype.CellClass);

  WorldMap = (function(superClass) {
    extend(WorldMap, superClass);

    function WorldMap() {
      return WorldMap.__super__.constructor.apply(this, arguments);
    }

    WorldMap.prototype.CellClass = WorldMapCell;

    WorldMap.prototype.PillboxClass = WorldPillbox;

    WorldMap.prototype.BaseClass = WorldBase;

    WorldMap.prototype.cellAtPixel = function(x, y) {
      return this.cellAtTile(floor(x / TILE_SIZE_PIXELS), floor(y / TILE_SIZE_PIXELS));
    };

    WorldMap.prototype.cellAtWorld = function(x, y) {
      return this.cellAtTile(floor(x / TILE_SIZE_WORLD), floor(y / TILE_SIZE_WORLD));
    };

    WorldMap.prototype.getRandomStart = function() {
      return this.starts[round(random() * (this.starts.length - 1))];
    };

    return WorldMap;

  })(Map);

  module.exports = WorldMap;

}).call(this);
