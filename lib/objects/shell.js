// Generated by CoffeeScript 1.12.7
(function() {
  var BoloObject, Destructable, Explosion, MineExplosion, PI, Shell, TILE_SIZE_WORLD, cos, distance, floor, round, sin,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  round = Math.round, floor = Math.floor, cos = Math.cos, sin = Math.sin, PI = Math.PI;

  distance = require('../helpers').distance;

  BoloObject = require('../object');

  TILE_SIZE_WORLD = require('../constants').TILE_SIZE_WORLD;

  Explosion = require('./explosion');

  MineExplosion = require('./mine_explosion');

  Destructable = (function() {
    function Destructable() {}

    Destructable.prototype.takeShellHit = function(shell) {};

    return Destructable;

  })();

  Shell = (function(superClass) {
    extend(Shell, superClass);

    Shell.prototype.updatePriority = 20;

    Shell.prototype.styled = false;

    function Shell(world) {
      this.world = world;
      this.spawn = bind(this.spawn, this);
      this.on('netSync', (function(_this) {
        return function() {
          return _this.updateCell();
        };
      })(this));
    }

    Shell.prototype.serialization = function(isCreate, p) {
      if (isCreate) {
        p('B', 'direction');
        p('O', 'owner');
        p('O', 'attribution');
        p('f', 'onWater');
      }
      p('H', 'x');
      p('H', 'y');
      return p('B', 'lifespan');
    };

    Shell.prototype.updateCell = function() {
      return this.cell = this.world.map.cellAtWorld(this.x, this.y);
    };

    Shell.prototype.getDirection16th = function() {
      return round((this.direction - 1) / 16) % 16;
    };

    Shell.prototype.getTile = function() {
      var tx;
      tx = this.getDirection16th();
      return [tx, 4];
    };

    Shell.prototype.spawn = function(owner, options) {
      var ref;
      options || (options = {});
      this.ref('owner', owner);
      if (this.owner.$.hasOwnProperty('owner_idx')) {
        this.ref('attribution', (ref = this.owner.$.owner) != null ? ref.$ : void 0);
      } else {
        this.ref('attribution', this.owner.$);
      }
      this.direction = options.direction || this.owner.$.direction;
      this.lifespan = (options.range || 7) * TILE_SIZE_WORLD / 32 - 2;
      this.onWater = options.onWater || false;
      this.x = this.owner.$.x;
      this.y = this.owner.$.y;
      return this.move();
    };

    Shell.prototype.update = function() {
      var collision, mode, ref, ref1, sfx, victim, x, y;
      this.move();
      collision = this.collide();
      if (collision) {
        mode = collision[0], victim = collision[1];
        sfx = victim.takeShellHit(this);
        if (mode === 'cell') {
          ref = this.cell.getWorldCoordinates(), x = ref[0], y = ref[1];
          this.world.soundEffect(sfx, x, y);
        } else {
          ref1 = this, x = ref1.x, y = ref1.y;
          victim.soundEffect(sfx);
        }
        return this.asplode(x, y, mode);
      } else if (this.lifespan-- === 0) {
        return this.asplode(this.x, this.y, 'eol');
      }
    };

    Shell.prototype.move = function() {
      this.radians || (this.radians = (256 - this.direction) * 2 * PI / 256);
      this.x += round(cos(this.radians) * 32);
      this.y += round(sin(this.radians) * 32);
      return this.updateCell();
    };

    Shell.prototype.collide = function() {
      var base, i, len, pill, ref, ref1, ref2, ref3, ref4, ref5, ref6, tank, terrainCollision, x, y;
      if ((pill = this.cell.pill) && pill.armour > 0 && pill !== ((ref = this.owner) != null ? ref.$ : void 0)) {
        ref1 = this.cell.getWorldCoordinates(), x = ref1[0], y = ref1[1];
        if (distance(this, {
          x: x,
          y: y
        }) <= 127) {
          return ['cell', pill];
        }
      }
      ref2 = this.world.tanks;
      for (i = 0, len = ref2.length; i < len; i++) {
        tank = ref2[i];
        if (tank !== ((ref3 = this.owner) != null ? ref3.$ : void 0) && tank.armour !== 255) {
          if (distance(this, tank) <= 127) {
            return ['tank', tank];
          }
        }
      }
      if (((ref4 = this.attribution) != null ? ref4.$ : void 0) === ((ref5 = this.owner) != null ? ref5.$ : void 0) && (base = this.cell.base) && base.armour > 4) {
        if (this.onWater || (((base != null ? base.owner : void 0) != null) && !base.owner.$.isAlly((ref6 = this.attribution) != null ? ref6.$ : void 0))) {
          return ['cell', base];
        }
      }
      terrainCollision = this.onWater ? !this.cell.isType('^', ' ', '%') : this.cell.isType('|', '}', '#', 'b');
      if (terrainCollision) {
        return ['cell', this.cell];
      }
    };

    Shell.prototype.asplode = function(x, y, mode) {
      var builder, i, len, ref, ref1, tank;
      ref = this.world.tanks;
      for (i = 0, len = ref.length; i < len; i++) {
        tank = ref[i];
        if (builder = tank.builder.$) {
          if ((ref1 = builder.order) !== builder.states.inTank && ref1 !== builder.states.parachuting) {
            if (mode === 'cell') {
              if (builder.cell === this.cell) {
                builder.kill();
              }
            } else {
              if (distance(this, builder) < (TILE_SIZE_WORLD / 2)) {
                builder.kill();
              }
            }
          }
        }
      }
      this.world.spawn(Explosion, x, y);
      this.world.spawn(MineExplosion, this.cell);
      return this.world.destroy(this);
    };

    return Shell;

  })(BoloObject);

  module.exports = Shell;

}).call(this);
