// Generated by CoffeeScript 1.12.7
(function() {
  var BaseRenderer, MAP_SIZE_PIXELS, PI, PIXEL_SIZE_WORLD, TEAM_COLORS, TILE_SIZE_PIXELS, TILE_SIZE_WORLD, cos, max, min, ref, round, sin, sounds, sqrt;

  min = Math.min, max = Math.max, round = Math.round, cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt;

  ref = require('../../constants'), TILE_SIZE_PIXELS = ref.TILE_SIZE_PIXELS, TILE_SIZE_WORLD = ref.TILE_SIZE_WORLD, PIXEL_SIZE_WORLD = ref.PIXEL_SIZE_WORLD, MAP_SIZE_PIXELS = ref.MAP_SIZE_PIXELS;

  sounds = require('../../sounds');

  TEAM_COLORS = require('../../team_colors');

  BaseRenderer = (function() {
    function BaseRenderer(world) {
      this.world = world;
      this.images = this.world.images;
      this.soundkit = this.world.soundkit;
      this.canvas = $('<canvas/>').appendTo('body');
      this.lastCenter = this.world.map.findCenterCell().getWorldCoordinates();
      this.mouse = [0, 0];
      this.canvas.click((function(_this) {
        return function(e) {
          return _this.handleClick(e);
        };
      })(this));
      this.canvas.mousemove((function(_this) {
        return function(e) {
          return _this.mouse = [e.pageX, e.pageY];
        };
      })(this));
      this.setup();
      this.handleResize();
      $(window).resize((function(_this) {
        return function() {
          return _this.handleResize();
        };
      })(this));
    }

    BaseRenderer.prototype.setup = function() {};

    BaseRenderer.prototype.centerOn = function(x, y, cb) {};

    BaseRenderer.prototype.drawTile = function(tx, ty, sdx, sdy) {};

    BaseRenderer.prototype.drawStyledTile = function(tx, ty, style, sdx, sdy) {};

    BaseRenderer.prototype.drawMap = function(sx, sy, w, h) {};

    BaseRenderer.prototype.drawBuilderIndicator = function(builder) {};

    BaseRenderer.prototype.onRetile = function(cell, tx, ty) {};

    BaseRenderer.prototype.draw = function() {
      var ref1, ref2, ref3, x, y;
      if (this.world.player) {
        ref1 = this.world.player, x = ref1.x, y = ref1.y;
        if (this.world.player.fireball != null) {
          ref2 = this.world.player.fireball.$, x = ref2.x, y = ref2.y;
        }
      } else {
        x = y = null;
      }
      if (!((x != null) && (y != null))) {
        ref3 = this.lastCenter, x = ref3[0], y = ref3[1];
      } else {
        this.lastCenter = [x, y];
      }
      this.centerOn(x, y, (function(_this) {
        return function(left, top, width, height) {
          var i, len, obj, ox, oy, ref4, ref5, tx, ty;
          _this.drawMap(left, top, width, height);
          ref4 = _this.world.objects;
          for (i = 0, len = ref4.length; i < len; i++) {
            obj = ref4[i];
            if (!((obj.styled != null) && (obj.x != null) && (obj.y != null))) {
              continue;
            }
            ref5 = obj.getTile(), tx = ref5[0], ty = ref5[1];
            ox = round(obj.x / PIXEL_SIZE_WORLD) - TILE_SIZE_PIXELS / 2;
            oy = round(obj.y / PIXEL_SIZE_WORLD) - TILE_SIZE_PIXELS / 2;
            switch (obj.styled) {
              case true:
                _this.drawStyledTile(tx, ty, obj.team, ox, oy);
                break;
              case false:
                _this.drawTile(tx, ty, ox, oy);
            }
          }
          return _this.drawOverlay();
        };
      })(this));
      if (this.hud) {
        return this.updateHud();
      }
    };

    BaseRenderer.prototype.playSound = function(sfx, x, y, owner) {
      var dist, dx, dy, mode, name;
      mode = this.world.player && owner === this.world.player ? 'Self' : (dx = x - this.lastCenter[0], dy = y - this.lastCenter[1], dist = sqrt(dx * dx + dy * dy), dist > 40 * TILE_SIZE_WORLD ? 'None' : dist > 15 * TILE_SIZE_WORLD ? 'Far' : 'Near');
      if (mode === 'None') {
        return;
      }
      name = (function() {
        switch (sfx) {
          case sounds.BIG_EXPLOSION:
            return "bigExplosion" + mode;
          case sounds.BUBBLES:
            if (mode === 'Self') {
              return "bubbles";
            }
            break;
          case sounds.FARMING_TREE:
            return "farmingTree" + mode;
          case sounds.HIT_TANK:
            return "hitTank" + mode;
          case sounds.MAN_BUILDING:
            return "manBuilding" + mode;
          case sounds.MAN_DYING:
            return "manDying" + mode;
          case sounds.MAN_LAY_MINE:
            if (mode === 'Near') {
              return "manLayMineNear";
            }
            break;
          case sounds.MINE_EXPLOSION:
            return "mineExplosion" + mode;
          case sounds.SHOOTING:
            return "shooting" + mode;
          case sounds.SHOT_BUILDING:
            return "shotBuilding" + mode;
          case sounds.SHOT_TREE:
            return "shotTree" + mode;
          case sounds.TANK_SINKING:
            return "tankSinking" + mode;
        }
      })();
      if (name) {
        return this.soundkit[name]();
      }
    };

    BaseRenderer.prototype.handleResize = function() {
      this.canvas[0].width = window.innerWidth;
      this.canvas[0].height = window.innerHeight;
      this.canvas.css({
        width: window.innerWidth + 'px',
        height: window.innerHeight + 'px'
      });
      return $('body').css({
        width: window.innerWidth + 'px',
        height: window.innerHeight + 'px'
      });
    };

    BaseRenderer.prototype.handleClick = function(e) {
      var action, cell, flexible, mx, my, ref1, ref2, trees;
      e.preventDefault();
      this.world.input.focus();
      if (!this.currentTool) {
        return;
      }
      ref1 = this.mouse, mx = ref1[0], my = ref1[1];
      cell = this.getCellAtScreen(mx, my);
      ref2 = this.world.checkBuildOrder(this.currentTool, cell), action = ref2[0], trees = ref2[1], flexible = ref2[2];
      if (action) {
        return this.world.buildOrder(action, trees, cell);
      }
    };

    BaseRenderer.prototype.getViewAreaAtWorld = function(x, y) {
      var height, left, ref1, top, width;
      ref1 = this.canvas[0], width = ref1.width, height = ref1.height;
      left = round(x / PIXEL_SIZE_WORLD - width / 2);
      left = max(0, min(MAP_SIZE_PIXELS - width, left));
      top = round(y / PIXEL_SIZE_WORLD - height / 2);
      top = max(0, min(MAP_SIZE_PIXELS - height, top));
      return [left, top, width, height];
    };

    BaseRenderer.prototype.getCellAtScreen = function(x, y) {
      var cameraX, cameraY, height, left, ref1, ref2, top, width;
      ref1 = this.lastCenter, cameraX = ref1[0], cameraY = ref1[1];
      ref2 = this.getViewAreaAtWorld(cameraX, cameraY), left = ref2[0], top = ref2[1], width = ref2[2], height = ref2[3];
      return this.world.map.cellAtPixel(left + x, top + y);
    };

    BaseRenderer.prototype.drawOverlay = function() {
      var b, player;
      if ((player = this.world.player) && player.armour !== 255) {
        b = player.builder.$;
        if (!(b.order === b.states.inTank || b.order === b.states.parachuting)) {
          this.drawBuilderIndicator(b);
        }
        this.drawReticle();
      }
      this.drawNames();
      return this.drawCursor();
    };

    BaseRenderer.prototype.drawReticle = function() {
      var distance, rad, x, y;
      distance = this.world.player.firingRange * TILE_SIZE_PIXELS;
      rad = (256 - this.world.player.direction) * 2 * PI / 256;
      x = round(this.world.player.x / PIXEL_SIZE_WORLD + cos(rad) * distance) - TILE_SIZE_PIXELS / 2;
      y = round(this.world.player.y / PIXEL_SIZE_WORLD + sin(rad) * distance) - TILE_SIZE_PIXELS / 2;
      return this.drawTile(17, 4, x, y);
    };

    BaseRenderer.prototype.drawCursor = function() {
      var cell, mx, my, ref1;
      ref1 = this.mouse, mx = ref1[0], my = ref1[1];
      cell = this.getCellAtScreen(mx, my);
      return this.drawTile(18, 6, cell.x * TILE_SIZE_PIXELS, cell.y * TILE_SIZE_PIXELS);
    };

    BaseRenderer.prototype.initHud = function() {
      this.hud = $('<div/>').appendTo('body');
      this.initHudTankStatus();
      this.initHudPillboxes();
      this.initHudBases();
      this.initHudToolSelect();
      this.initHudNotices();
      return this.updateHud();
    };

    BaseRenderer.prototype.initHudTankStatus = function() {
      var bar, container, i, indicator, len, ref1;
      container = $('<div/>', {
        id: 'tankStatus'
      }).appendTo(this.hud);
      $('<div/>', {
        "class": 'deco'
      }).appendTo(container);
      this.tankIndicators = {};
      ref1 = ['shells', 'mines', 'armour', 'trees'];
      for (i = 0, len = ref1.length; i < len; i++) {
        indicator = ref1[i];
        bar = $('<div/>', {
          "class": 'gauge',
          id: "tank-" + indicator
        }).appendTo(container);
        this.tankIndicators[indicator] = $('<div class="gauge-content"></div>').appendTo(bar);
      }
    };

    BaseRenderer.prototype.initHudPillboxes = function() {
      var container, node, pill;
      container = $('<div/>', {
        id: 'pillStatus'
      }).appendTo(this.hud);
      $('<div/>', {
        "class": 'deco'
      }).appendTo(container);
      this.pillIndicators = (function() {
        var i, len, ref1, results;
        ref1 = this.world.map.pills;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          pill = ref1[i];
          node = $('<div/>', {
            "class": 'pill'
          }).appendTo(container);
          results.push([node, pill]);
        }
        return results;
      }).call(this);
    };

    BaseRenderer.prototype.initHudBases = function() {
      var base, container, node;
      container = $('<div/>', {
        id: 'baseStatus'
      }).appendTo(this.hud);
      $('<div/>', {
        "class": 'deco'
      }).appendTo(container);
      this.baseIndicators = (function() {
        var i, len, ref1, results;
        ref1 = this.world.map.bases;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          base = ref1[i];
          node = $('<div/>', {
            "class": 'base'
          }).appendTo(container);
          results.push([node, base]);
        }
        return results;
      }).call(this);
    };

    BaseRenderer.prototype.initHudToolSelect = function() {
      var i, len, ref1, toolType, tools;
      this.currentTool = null;
      tools = $('<div id="tool-select" />').appendTo(this.hud);
      ref1 = ['forest', 'road', 'building', 'pillbox', 'mine'];
      for (i = 0, len = ref1.length; i < len; i++) {
        toolType = ref1[i];
        this.initHudTool(tools, toolType);
      }
      return tools.buttonset();
    };

    BaseRenderer.prototype.initHudTool = function(tools, toolType) {
      var label, tool, toolname;
      toolname = "tool-" + toolType;
      tool = $('<input/>', {
        type: 'radio',
        name: 'tool',
        id: toolname
      }).appendTo(tools);
      label = $('<label/>', {
        "for": toolname
      }).appendTo(tools);
      label.append($('<span/>', {
        "class": "bolo-tool bolo-" + toolname
      }));
      return tool.click((function(_this) {
        return function(e) {
          if (_this.currentTool === toolType) {
            _this.currentTool = null;
            tools.find('input').removeAttr('checked');
            tools.buttonset('refresh');
          } else {
            _this.currentTool = toolType;
          }
          return _this.world.input.focus();
        };
      })(this));
    };

    BaseRenderer.prototype.initHudNotices = function() {
      if (location.hostname.split('.')[1] === 'github') {
        $('<div/>').html('This is a work-in-progress; less than alpha quality!<br>\nTo see multiplayer in action, follow instructions on Github.').css({
          'position': 'absolute',
          'top': '70px',
          'left': '0px',
          'width': '100%',
          'text-align': 'center',
          'font-family': 'monospace',
          'font-size': '16px',
          'font-weight': 'bold',
          'color': 'white'
        }).appendTo(this.hud);
      }
      if (location.hostname.split('.')[1] === 'github' || location.hostname.substr(-6) === '.no.de') {
        return $('<a href="http://github.com/stephank/orona"></a>').css({
          'position': 'absolute',
          'top': '0px',
          'right': '0px'
        }).html('<img src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub">').appendTo(this.hud);
      }
    };

    BaseRenderer.prototype.updateHud = function() {
      var base, color, i, j, len, len1, node, p, pill, prop, ref1, ref2, ref3, ref4, ref5, results, statuskey, value;
      ref1 = this.pillIndicators;
      for (i = 0, len = ref1.length; i < len; i++) {
        ref2 = ref1[i], node = ref2[0], pill = ref2[1];
        statuskey = pill.inTank + ";" + pill.carried + ";" + pill.armour + ";" + pill.team;
        if (pill.hudStatusKey === statuskey) {
          continue;
        }
        pill.hudStatusKey = statuskey;
        if (pill.inTank || pill.carried) {
          node.attr('status', 'carried');
        } else if (pill.armour === 0) {
          node.attr('status', 'dead');
        } else {
          node.attr('status', 'healthy');
        }
        color = TEAM_COLORS[pill.team] || {
          r: 112,
          g: 112,
          b: 112
        };
        node.css({
          'background-color': "rgb(" + color.r + "," + color.g + "," + color.b + ")"
        });
      }
      ref3 = this.baseIndicators;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        ref4 = ref3[j], node = ref4[0], base = ref4[1];
        statuskey = base.armour + ";" + base.team;
        if (base.hudStatusKey === statuskey) {
          continue;
        }
        base.hudStatusKey = statuskey;
        if (base.armour <= 9) {
          node.attr('status', 'vulnerable');
        } else {
          node.attr('status', 'healthy');
        }
        color = TEAM_COLORS[base.team] || {
          r: 112,
          g: 112,
          b: 112
        };
        node.css({
          'background-color': "rgb(" + color.r + "," + color.g + "," + color.b + ")"
        });
      }
      p = this.world.player;
      p.hudLastStatus || (p.hudLastStatus = {});
      ref5 = this.tankIndicators;
      results = [];
      for (prop in ref5) {
        node = ref5[prop];
        value = p.armour === 255 ? 0 : p[prop];
        if (p.hudLastStatus[prop] === value) {
          continue;
        }
        p.hudLastStatus[prop] = value;
        results.push(node.css({
          height: (round(value / 40 * 100)) + "%"
        }));
      }
      return results;
    };

    return BaseRenderer;

  })();

  module.exports = BaseRenderer;

}).call(this);
