// Generated by CoffeeScript 1.12.7
(function() {
  var BaseWorld, ClientWorld, buildUnpacker, ref, unpack,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  BaseWorld = require('../base');

  ref = require('../../struct'), unpack = ref.unpack, buildUnpacker = ref.buildUnpacker;

  ClientWorld = (function(superClass) {
    extend(ClientWorld, superClass);

    ClientWorld.prototype.registerType = function(type) {
      if (!this.hasOwnProperty('types')) {
        this.types = [];
      }
      return this.types.push(type);
    };

    function ClientWorld() {
      ClientWorld.__super__.constructor.apply(this, arguments);
      this.changes = [];
    }

    ClientWorld.prototype.spawn = function() {
      var args, obj, type;
      type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      obj = this.insert(new type(this));
      this.changes.unshift(['create', obj.idx, obj]);
      obj._net_transient = true;
      obj.spawn.apply(obj, args);
      obj.anySpawn();
      return obj;
    };

    ClientWorld.prototype.update = function(obj) {
      obj.update();
      obj.emit('update');
      obj.emit('anyUpdate');
      return obj;
    };

    ClientWorld.prototype.destroy = function(obj) {
      this.changes.unshift(['destroy', obj.idx, obj]);
      this.remove(obj);
      obj.emit('destroy');
      if (obj._net_transient) {
        obj.emit('finalize');
      }
      return obj;
    };

    ClientWorld.prototype.netRestore = function() {
      var i, idx, j, k, len, len1, obj, ref1, ref2, ref3, type;
      if (!(this.changes.length > 0)) {
        return;
      }
      ref1 = this.changes;
      for (j = 0, len = ref1.length; j < len; j++) {
        ref2 = ref1[j], type = ref2[0], idx = ref2[1], obj = ref2[2];
        switch (type) {
          case 'create':
            if (obj.transient && !obj._net_revived) {
              obj.emit('finalize');
            }
            this.objects.splice(idx, 1);
            break;
          case 'destroy':
            obj._net_revived = true;
            this.objects.splice(idx, 0, obj);
        }
      }
      this.changes = [];
      ref3 = this.objects;
      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
        obj = ref3[i];
        obj.idx = i;
      }
    };

    ClientWorld.prototype.netSpawn = function(data, offset) {
      var obj, type;
      type = this.types[data[offset]];
      obj = this.insert(new type(this));
      obj._net_transient = false;
      obj._net_new = true;
      return 1;
    };

    ClientWorld.prototype.netUpdate = function(obj, data, offset) {
      var bytes, changes, ref1;
      ref1 = this.deserialize(obj, data, offset, obj._net_new), bytes = ref1[0], changes = ref1[1];
      if (obj._net_new) {
        obj.netSpawn();
        obj.anySpawn();
        obj._net_new = false;
      } else {
        obj.emit('netUpdate', changes);
        obj.emit('anyUpdate');
      }
      obj.emit('netSync');
      return bytes;
    };

    ClientWorld.prototype.netDestroy = function(data, offset) {
      var bytes, obj, obj_idx, ref1, ref2;
      ref1 = unpack('H', data, offset), (ref2 = ref1[0], obj_idx = ref2[0]), bytes = ref1[1];
      obj = this.objects[obj_idx];
      if (!obj._net_new) {
        obj.emit('netDestroy');
        obj.emit('anyDestroy');
        obj.emit('finalize');
      }
      this.remove(obj);
      return bytes;
    };

    ClientWorld.prototype.netTick = function(data, offset) {
      var bytes, j, len, obj, ref1;
      bytes = 0;
      ref1 = this.objects;
      for (j = 0, len = ref1.length; j < len; j++) {
        obj = ref1[j];
        bytes += this.netUpdate(obj, data, offset + bytes);
      }
      return bytes;
    };

    ClientWorld.prototype.deserialize = function(obj, data, offset, isCreate) {
      var changes, unpacker;
      unpacker = buildUnpacker(data, offset);
      changes = {};
      obj.serialization(isCreate, (function(_this) {
        return function(specifier, attribute, options) {
          var oldValue, other, ref1, value;
          options || (options = {});
          if (specifier === 'O') {
            other = _this.objects[unpacker('H')];
            if ((oldValue = (ref1 = obj[attribute]) != null ? ref1.$ : void 0) !== other) {
              changes[attribute] = oldValue;
              obj.ref(attribute, other);
            }
          } else {
            value = unpacker(specifier);
            if (options.rx != null) {
              value = options.rx(value);
            }
            if ((oldValue = obj[attribute]) !== value) {
              changes[attribute] = oldValue;
              obj[attribute] = value;
            }
          }
        };
      })(this));
      return [unpacker.finish(), changes];
    };

    return ClientWorld;

  })(BaseWorld);

  module.exports = ClientWorld;

}).call(this);
